#import sectionimport pandas as pdfrom matplotlib import cm, pyplot as pltimport numpy as npfrom climdiv_data import *from simpleNIPA import *from atmos_ocean_data import *from utils import sstMapimport matplotlib as mplfrom utils import *import mpl_toolkitsimport csvimport mathimport xarray as xr#### USER INPUT ##### Select the input-output files:e#climate index for "pos"/"neg" segmentation (in this case NAO)#path to the input data for North Atlantic Oscillation (NAO)index_file = './DATA/mei.txt'## NB:  the file in this path contains the values of a specific climate index #       (such as NAO, MJO, ecc). Thus, there is not lat/lon involved because #       Climate Indices are single values that represent the behavior of a #       climate signal. In conclusion: this is a simple temporal #       serie.#path to the dataset of daily precipitation covering the working area. #This file allows to know the precipitation for the correlation analysis #between location-specific precipitation and golbal vars (such as SST, Z200, #Z500, Z850, ...)clim_file = './DATA/tpNetherlands.txt'## NB:  the file in this path contains the precipitation data only for the #       desired location (single cell). #       Thus, there is not lat/lon involved; this is a simple temporal serie #       located in the working area.####data_var = '/Users/francesco/Documents/data_1,5x1,5/Z850'#####defining the name of the output PNG filefilename = 'testComoNAO'# Original Settings:M = 2               # number of climate signal's phasesn_obs = 1           # number of observations (months)lag = 1             # lag-time (months) --> 3 = seasonalmonths = [1]        # months to consider (J,F,M)startyr = 1980      # beginning of the time period to analyzen_yrs = 36          # number of years to analyze# Select the type of experiment:# crv_flag:#   True  = runs NIPA with crossvalidation#   False = runs NIPA without crossvalidation and save the first SST-Principal Component for multi-variate model#crv_flag = Falsemap_flag = True##################### creation of an array of years from the starting year to the ending year of the analysisyears = np.arange(startyr, startyr+n_yrs)#this function takes information about the seasons, years, and type of divisional#data to look at, and creates appropriate kwgroups (parameters) to load the datakwgroups = create_kwgroups(debug = True, climdata_months = months,                        climdata_startyr = startyr, n_yrs = n_yrs,                        n_mon_sst = n_obs, n_mon_index = n_obs, sst_lag = lag,                        n_phases = M, phases_even = True,                        index_lag = lag,                        index_fp = index_file,                        climdata_fp = clim_file)#here we call the get_data function giving the just created kwgroups as input#with this function we download the missing data: SST (in lat,lon,time space)#After we will perform a PCA in order to reduce the dimensionality of this #dataset to a single dimension in order also to compare the SST with the other #monodimensional vars (NAO,precipitation)climdata, sst, index, phaseind = get_data(kwgroups, data_var)#here we set up where to save the output mapfp = './maps/%s' % (filename)#here the plot settings are initializedfig, axes = plt.subplots(M, 1, figsize = (6, 12))#here a dictionary with 3 keys (year, data, hindcast) is created to be then#filled during the processtimeseries = {'years' : [], 'data' : [], 'hindcast': []}#here is where the PC1 will be storedpc1 = {'pc1':[]}print('NIPA running...')#%%#START OF THE ANALYTICAL PART# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#this section will be executed only if we consider the climate signal as "single phased" (M=1)if M == 1:    phase = 'allyears'    model = NIPAphase(climdata, sst, index, phaseind[phase])    model.phase = phase    model.years = years[phaseind[phase]]    model.bootcorr(corrconf = 0.95)    model.gridCheck()    model.crossvalpcr(xval = crv_flag)    timeseries['years'] = model.years    timeseries['data'] = model.clim_data    timeseries['hindcast'] = model.hindcast    print( timeseries['years'])    print( timeseries['data'])        if map_flag:        fig, axes, m = sstMap(model, fig = fig, ax = axes)        axes.set_title('%s, %.2f' % (phase, model.correlation))        fig.savefig(fp)        plt.close(fig)# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++#this section will be executed only with pluri-phased climate signals #(it actually works only for 2 phases)else:    for phase, ax in zip(phaseind, axes):        model = NIPAphase(climdata, sst, index, phaseind[phase])                #assignment of the phase of the climate signal to the key named "phase" in the i-esima iteration        model.phase = phase                #this line does the following operations:                #   0. The  "phaseind" contains 2 items (neg & pos) composed by         #   boolean values related to the accordance/discordance wrt the         #   name of the item itself (a 'False' boolean value in the 'neg'         #   item corrisponds to a postive phase)                #   1. "phaseind[phase]" selects the item corresponding to the         #   considered phase for this iteration (if the considered phase         #   is 'neg' --> "phaseind[phase]" == "phaseind['neg']" ).                #   2. The pattern of boolen values obtained at step 1. is then used         #   to select the subset of years corresponding to the true values         #   with "years[phaseind[phase]]" (if the result of "phaseind[phase]"         #   is "[True, False, True, False] and the full set of years is [        #   2001, 2002, 2003, 2004], then the result will be [2001,2003]")        model.years = years[phaseind[phase]]                #here the minimum correlation values between preseasonal SST and         #precipitation is set (if the correlation is lower than 0.95 the         #SST values of that location are not considered)        model.bootcorr(corrconf = 0.95)                #given that "gridCheck()" is a function inside the "NIPAphase" class         #and given that we assigned to the variable "model" an instance of         #the NIPAphase class, now we can simply call the "gridCheck()"         #function (and any other function inside that class) by simply using        #the notation "model.<function>"        model.gridCheck()                # this fuction is the one that actually computes the PC1        model.crossvalpcr(xval = crv_flag)                        #append model.years values identified before to the key "years" in the dictionary "timeseries"        timeseries['years'].append(model.years)        #append model.data values to the key "data" in the dictionary "timeseries"        timeseries['data'].append(model.clim_data)        #append model.hindcast values to the key "hindcast" in the dictionary "timeseries"        timeseries['hindcast'].append(model.hindcast)                #if the crossvalidation value is set to False the first principal         #component value is stored into the "pc1" key of the "pc1" vriable        #NOT SURE ABOUT THE "WHY" OF THIS        if not crv_flag:            if hasattr(model,'pc1'):                pc1['pc1'].append(model.pc1)                #if "map_flag" variable is set on "true", then the resultin plot is produced        if map_flag:            #the data for the plot are stored in the model variable (passed in the sstMap function)            fig, ax, m = sstMap(model, fig = fig, ax = ax)            ax.set_title('%s, %.2f' % (phase, model.correlation))            fig.savefig(fp)            plt.close(fig)# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++          ### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #### save timeseries (exceptions handled only for 2 phase analysis)# this part of the code is ment to handle exceptions in the case in which # the analysis is executed with 2 phaes            #if the hindcast for the first instant in the timeseries is only 1if np.size(timeseries['hindcast'][0]) == 1:    #and is also NaN    if math.isnan(timeseries['hindcast'][0]):        # it means that there is no result for the first phase -> consider         # only the second set of results        timeseries['years'] = timeseries['years'][1]        timeseries['data'] = timeseries['data'][1]        timeseries['hindcast'] = timeseries['hindcast'][1]        ## SAME FOR THE SECOND INSTANT#if the hindcast for the second instant in the timeseries is only 1elif np.size(timeseries['hindcast'][1]) == 1: ##### QUA DA UN ERRORE FORSE ...    #and is also NaN    if math.isnan(timeseries['hindcast'][1]):        # it means that there is no result for the second phase -> consider         # only the first set of results        timeseries['years'] = timeseries['years'][0]        timeseries['data'] = timeseries['data'][0]        timeseries['hindcast'] = timeseries['hindcast'][0]        #if both the first and the second phase have results, do a concatenation #and use them bothelse:    timeseries['years'] = np.concatenate(timeseries['years'])    timeseries['data'] = np.concatenate(timeseries['data'])    timeseries['hindcast'] = np.concatenate(timeseries['hindcast'])### ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #### once the exceptions have been handled (only first phase, only second phase # or both phses present) the data are saved in a pandas dataframedf = pd.DataFrame(timeseries)# the dataframe is saved in a csv filets_file = './output/%s_timeseries.csv' % (filename)df.to_csv(ts_file)# if "crv_flag" was set to False a csv file containing the first principal # components of the SSTs is also saved (NOT CLEAR WHY IT IS NOT CREATED IF # "crv_flag" is set to false)if not crv_flag:    # save PC    pc1['pc1'] = np.concatenate(pc1['pc1'])    pc_file = './output/%s_pc1SST.csv' % (filename)    df1 = pd.DataFrame(pc1)    df1.to_csv(pc_file)print( 'NIPA run completed')       